# modul31
Задача 1. Умный указатель на игрушку


Что нужно сделать:
Реализуйте умный указатель shared_ptr_toy с распределённым доступом и механикой подсчёта ссылок для класса Toy, реализованного в задании. 

Указатель должен иметь все стандартные методы класса и должен быть функциональной заменой использованию shared_ptr<Toy>. 

Также реализуйте свободную функцию make_shared_toy, принимающую набор аргументов и конструирующую игрушку либо от названия, либо копируя другую игрушку. 


Чек-лист для проверки задачи
Класс называется shared_ptr_toy
Реализован конструктор, конструктор копий, оператор присваивания копированием, деструктор и функция make_shared


Задача 2. Реализация класса графа


Что нужно сделать:
В любом доступном источнике прочитайте, что такое графы в дискретной математике и как граф можно представить в программе (что такое матрицы смежности и списки смежности)

Вам дан базовый интерфейс для представления ориентированного графа

Необходимо написать две реализаций интерфейса:

ListGraph, хранящий граф в виде массива списков смежности,
MatrixGraph, хранящий граф в виде матрицы смежности,
Также необходимо реализовать конструктор, принимающий IGraph*. Такой конструктор должен скопировать переданный граф в создаваемый объект (обратите внимание, что иногда в одну реализацию графа копируется другая) Реализуйте в том числе все конструкторы копий и операторы присваивания, если необходимо.



class IGraph {

public:

    virtual ~IGraph() {}

    IGraph() {};

    IGraph(IGraph *_oth) {};

    virtual void AddEdge(int from, int to) = 0; // Метод принимает вершины начала и конца ребра и добавляет ребро

    virtual int VerticesCount() const = 0; // Метод должен считать текущее количество вершин

    virtual void GetNextVertices(int vertex, std::vector<int> &vertices) const = 0; // Для конкретной вершины метод выводит в вектор “вершины” все вершины, в которые можно дойти по ребру из данной

    virtual void GetPrevVertices(int vertex, std::vector<int> &vertices) const = 0; // Для конкретной вершины метод выводит в вектор “вершины” все вершины, из которых можно дойти по ребру в данную

};
